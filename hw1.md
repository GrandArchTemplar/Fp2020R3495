# Домашечка 1
## Общее положение
1. За каждый блок можно получить не более 10 баллов. Каждая верно выполненная задача это 1 балл, если не указано иначе. 
2. В сумме за 5 блоков можно набрать не более 40 баллов.
3. Остальные баллы сгорают :с 
4. Вообще говоря, ставится 1 балл за задание не только в том случае, если оно работает верно, но и например ассимптотически **достаточно** быстро. Потому не рекомендуется делать в минимум. 
5. Дедлайн -- 25 декабря, но все может измениться. 
6. Эта домашка требует разговора со мной в, допустим дискорде, чтобы баллы за неё перешли в реальные, либо разговора до/после/во время пары. 
7. Форма сдачи -- ссылка на публичный/приватный репозиторий (гитхаб, гитлаб, битбакет, сурсфордж, что-то ещё, что может работать с гитом) с моим доступом (примерно везде @GrandArchTemplar) 
8. В репозитории должна быть папка, которую я смогу запустить либо загрузить существенное содержимое этой папки(файлики с расширением .hs) без **особого** страдания в ghci
9. Все должно компилироваться. Если не компилируется то, грустно
10. NEW! Задачи, можно сдавать на окамле, котлине, расте, если сможете убедить меня, что семантически вы не отошли от **каноничного** фп (количество вопросов на сдаче примерно х5)
11. Компилировать код я буду с флагом `-Wall`(если пишите на хаскеле). В связи с чем ожидаю, что у проектов не будет ворнингов или их будет суперсупер мало(ближе к экзамену я уточню)
## Задание 1 (тривиальный блок)
Основная цель -- понять синтаксис хаскеля
1. Напишите функцию `f1_1 :: Int -> Int`, которая возвращает то же число, что и принимает
```
f1_1 5
>>> 5
```
2. Напишите функцию `f2_1 :: Int -> Bool`, которая проверяет, является ли модуль числа простым (0 считать не простым)
```
f2_1 3
>>> True
f2_1 1
>>> False
f2_1 (-3)
>>> True
```
3. Напишите функцию `f3_1 :: Bool -> Bool -> Int`, которая берет два була и возвращает сумму их как Int
```
f3_1 True True
>>> 2
```
4. Напишите функцию `f4_1 :: Int -> Int`, которая возвращает cумму делителей числа (само число не добавлять в сумму) 
```
f4_1 6
>>> 6
f4_1 5
>>> 1
f4_1 (-6)
>>> 6
```
5. Напишите функцию `f5_1 :: Int -> Int`, которая возвращает следующее совершенное(https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%B2%D0%B5%D1%80%D1%88%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE) число
```
f5_1 5
>>> 6
f5_1 6
>>> 28
```
6.Напишите функцию `f6_1 :: Integer -> Integer`, которая возвращает следующее совершенное число
```
f6_1 5
>>> 6
f6_1 6
>>> 28
```
7. Напишите функцию `f7_1 :: Int -> Int -> Int`, которая возвращает функцию Аккермана(https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%90%D0%BA%D0%BA%D0%B5%D1%80%D0%BC%D0%B0%D0%BD%D0%B0)
```
f7_1 0 0
>>> 1
f7_1 3 4
>>> 125
```
8.Напишите функцию `f8_1 :: Int -> Int -> Integer`, которая возвращает функцию Аккермана
```
f8_1 0 0
>>> 1
f8_1 3 4
>>> 125
```
9. Напишите функцию 
`f9_1 :: Double -> Double -> Double -> Double -> (Double, Double, Double)`, такую что `f9_1 a b c d` возвращает тройку чисел `(x1, x2, x3)`, удовлетворяющую следующему равенству
`(a^(1/3)*xi + d^(1/3))(a^(2/3)*xi^2 - (a*d)^(1/3)*xi + d^(2/3)) = -xi*(c+b*xi)` для i = 1, 2, 3 
Ожидается, что `a, b, c, d` такие, что всегда существуют различные между собой три числа `x1, x2, x3`, удовлетворяющие условию
10. Напишите функцию `f10_1 :: Double -> Double -> (Double, Double)` которая является аналогом целочисленного деления с остатком
```
f10_1 6.0 2.7
>>> (2.0, 0.6)
```
11. Напишите функцию `f11_1 :: Int -> Double`, такой что `f11_1 k` вычисляет первые `k` шагов цепной дроби согласно формуле Браункера для вычисления числа `0.25pi`
12. Напишите функцию `f12_1 :: Int`, такой что выражения `f12_1 == 1 + 1` выдавало истину 
## Задание 2 (работа с чуть более сложными типами)
1. Напишите функцию `antisort :: Ord a => [a] -> [a]`, возвращаю список -- результат перестановки элементов исходного списка, являющимся неотсортированным по убыванию или возрастанию. На вход подаются списки длинной больше 2. 
```
antisort [1, 2, 3]
>>> [1, 3, 2]
```
2. Напишите функцию `antiprimes :: Int -> [Integer]`, возвращающую список первых k чисел неявляющихся простыми
```
antiprimes 5 = [1, 4, 6, 8, 10]
```
3. Напишите функцию `antiunion :: Eq a => [a] -> [a] -> [a]`, возвращающую список элементов лежащий строго в первом или строго во втором списке
```
antiunion [1, 2, 3] [2, 3, 4]
>>> [1, 4]
```
4. Напишите функцию `antimerge :: Eq a => [a] -> [(Int, a)]`, возвращающую список пар, где каждая пара это число элементов и сам элемент в листе
```
antimerge [1, 2, 1, 2, 1] 
>>> [(3, 1), (2, 2)]
```
5. Напишите функцию `antiintercalate :: Eq a => [a] -> [(Int, a)]`, возвращающую список пар, где каждая пара это количество повторений элемента подряд
```
antiintercalate [1, 1, 1, 2, 2, 1, 1, 1, 3]
>>> [(3, 1), (2, 2), (3, 1), (1, 3)]
```
6. Напишите функцию `antiantiintercalate :: [(Int, a)] -> [a]`, восстанавливающую по разбиению из 5 функции исходный лист
```
antiantiintercalate [(3, 1), (2, 2), (3, 1), (1, 3)]
>>> [1, 1, 1, 2, 2, 1, 1, 1, 3]
```
7. Напишите функцию `getNumberOrNot :: String -> Maybe Integer` 
Возвращающую число, если строка является числом или `Nothing` если нет. Ваша функция должна игнорировать пробелы, отступы, табуляции и переходы строк. 
```
getNumberOrNot "1bc"
>>> Nothing
getNumberOrNot " 123"
>>> Just 123
getNumberOrNot "123"
>>> Just 123
getNumberOrNot "123 456"
>>> Just 123456
```
8. Напишите функцию `getMailDomainOrNot :: String -> Maybe String`, которая возвращает доменное имя почты, если введенная строка является валидным почтовым адресом(https://help.xmatters.com/ondemand/trial/valid_email_format.htm#:~:text=A%20valid%20email%20address%20consists,com%22%20is%20the%20email%20domain.)
```
getMailDomainOrNot "bad-adress@mail.r"
>>> Nothing 
getMailDomainOrNot "super-bad-adress-lol@gmail.com"
>>> Just "gmail.com"
```
9. Напишите функцию `maybeMaybeMaybeMaybeMaybeMaybeMaybeOrNot ::Maybe (Maybe (Maybe (Maybe (Maybe (Maybe a))))) -> a -> a` 
Возвращающую значение, если это возможно, иначе возвращающую второй аргумент 
10. Напишите функцию `stupidTraverse :: [Maybe a] -> Maybe [(a, a, a, a)]`, которая принимает список длины k, фильтрует элементы Nothing, и возвращает Nothing, если число элементов некратно четырем или число элементов ноль, иначе возвращает список элементов записанных в кортежах по четыре.
```
stupidTraverse [Just 1, Just 2, Just 3, Just 4, Just 5, Just 6, Just 7, Just 7]
>>> Just [(1, 2, 3, 4), (5, 6, 7, 7)]
stupidTraverse [Nothing, Nothing, Nothing, Nothing]
>>> Nothing
```
1. Напишите функцию `dfs :: [(Int, Int)] -> Int -> Int -> Bool` 
На вход подается список ребер (i, j), где i -- ребро откуда направляется, j -- ребро куда входит. Следующие два аргумента -- вершины откуда и куда мы ищем путь. Если путь есть, вернуть True, иначе False. Искать необходимо при помощи алгоритма dfs. Нет проблем, если асимптотика будет отличаться от привычных реализаций.
```
dfs [(1, 2), (2, 3)] 1 3
>>> True
dfs [(1, 2), (2, 3)] 3 1
>>> False
```
2. Напишите функцию `fatWay :: Num a => [(Int, Int, a)] -> Int -> Int -> a` 
На вход подается список ребер (i, j, w), где i -- ребро откуда направляется, j -- ребро куда входит, w -- вес такой, что abs(w) = w. Следующие два аргумента -- вершины откуда и куда мы ищем путь. Если путь есть и не один, то вернуть второй по весу (по возрастанию) вес пути, иначе fromInteger (negate 1). Искать необходимо при помощи алгоритма dfs. Нет проблем, если асимптотика будет отличаться от привычных реализаций.
```
fatWay [(1, 2, 1), (2, 3, 2), (1, 3, 7)] 1 3 
>>> 7
fatWay [(1, 2, 1), (2, 3, 1)] 1 3
>>> -1
```
## Задание 3 (типовые задачи)
В этом блоке в том числе задачи будут заключаться в конструировании типов. Формат ответа в таких заданиях -- некоторый тип данных T. Так ваш тип данных должен быть **достаточно** интуитивно понятным. Все следующие задачи должны работать на любых входных данных. 
Пример: `data NonEmptyList = Single a | Poly a [a]` является типом данных для непустого листа. Заметьте, что здесь сложно будет создать пустой список, особенно если вы не знаете тип данных `a`.
Для более приятного существования рекомендуется использовать конструкцию `deriving Show`. Например `data F = G deriving Show`
1. Создайте тип данных `Tree a` реализующие тернарное дерево. Здесь и далее ожидается, что дерево будет символизировать тернарное дерево поиска для которого верен инвариант `maxValue _Left <= _minValue _Central <= _maxValue _Central <= value <= minValue _Right`. `_Left, _Central, _Right` -- это соответствующие поддеревья, а `value` -- значение в узле дерева.
2. Напишите функцию `seek :: Ord a => a -> Tree a -> Maybe a`, которая ищет значение в `Tree a` и возвращает его, если оно присутствует. Асимптотика -- `o(n)`.
```
seek 2 tree 
>>> Just 2 
seek 3 tree
>>> Nothing
```
3. Напишите функцию `delete :: Ord a => a -> Tree a -> Tree a`, удаляющее значение из дерева, если оно присутствует. Иначе возвращает исходное дерево. Асимптотика -- `o(n)` 
4. Напишите функцию `add :: Ord a => a -> Tree a -> Tree a`, добавляющее значение в дерево, если его не присутствует. Иначе возвращает исходное дерево. Асимптотика -- `o(n)`. 
5. Напишите функцию `merge :: Ord a => Tree a -> Tree a -> Tree a`, смешивающих три дерева в одно. Асимптотика -- `O(n)`. 
6. Напишите функцию `balance :: Ord a => Tree a -> Tree a`, возвращающее дерево, в котором суммарное количество вершин в каждом из поддеревьев отличается не более чем на 2. Асимптотика -- `O(n*ln(n))`.
7. Напишите функцию `kmin :: Ord a => Int -> Tree a -> [a]`, возвращающее первые `min(k, _размер_дерева_)` минимумов дерева.

Для следующего типа данных `data N = Z | S N` введём интерпретацию как натуральных чисел. Так `2 ~ S (S Z), 0 ~ Z, 5 ~ S (S (S (S (S Z))))`
8. Напишите функцию сложения `natSum :: N -> N -> N`
```
natSum (S Z) (S Z) 
>>> S (S Z)
```
9. Напишите функцию умножения `natMult :: N -> N -> N`
```
natMult (S (S Z)) (S (S (S Z)))
>>> S (S (S (S (S (S Z)))))
```
10. Напишите функцию гипероператоров: `superNat :: N -> N -> N -> N`
```
superNat Z (S (S (S Z))) (S (S Z)) -- 3 + 2 = 5
>>> S (S (S (S (S Z))))
superNat (S Z) (S (S (S Z))) (S (S Z)) -- 3 * 2 = 6
>>> S (S (S (S (S (S Z)))))
superNat (S (S Z)) (S (S (S Z))) (S (S Z)) -- 3^2 = 9
>>> S (S (S (S (S (S (S (S (S Z))))))))
```
1. Реализуйте инстанс `Functor (Tree a)`.
2. Реализуйте инстанс `Ord N`. 
## Задание 4 (монадки)
1. Напишите функцию `apb :: IO ()`, которая принимает два целых числа и возвращает их сумму (в консоль).
2. Напишите функцию `whileNotZero :: IO ()`, которая принимает числа(через строчку) до тех пор, пока они не равны 0 и возвращает их сумму(в консоль)
3. Напишите функцию `fakeRandom :: IO()`, которая принимает два числа `seed` и `k` и выводит первые `k` псевдослучайных чисел с зерном `seed`. Алгоритм рандомизации -- любой **достаточно** адекватный

Пусть дан тип данных файловой системы 
```
data FS = File String String | Directory String [FS] -- первый аргумент у файла и директории -- название, а второй у файла -- содержание файла
``` 
Далее надо будет написать функцию `runFS :: FS -> IO ()`, принимающую команды на вход и на основе этих команд выполняющие соответствующие команды. При команде, которой не существует программа должна выводить сообщение вида `command $command_name doesn't exist`, например `command f*ck_this_task doesn't exist`. Если аргументов слишком мало или слишком много, то добавьте сообщение об ошибке вида `"command $command_name require more/less arguments"`
4. Изначально необходимо поддерживать команду `"exit"`, которая завершает работу FS.
5. Добавьте обработку команды `"ls"`, которая выводит имена файлов и папок в системе.
6. Добавьте обработку команды `"cd $dir_name"`, которая переводит состояние файловой системы в такое, будто бы вы перешли по папке `$dir_name`. Если папки не существует, то выведите ошибку в формате `"Directory $dir_name doesn't exist"`
7. Добавьте возможность переходить при помощи `"cd .."` на более высокий уровень
8. Добавьте возможность создать папку при помощи команды `"mkdir $dir_name"`. Если папка уже существует, то выведите сообщение об ошибке в формате `"Directory $dir_name already exists"`
9. Добавьте возможность создать файл при помощи команды `"touch $file_name $file_value"`. Если подан всего один аргумент, то создавайте пустой файл. Если файл с таким именем уже существует, то выведите сообщение об ошибке в формате `"File $file_name already exists"` 
10. Добавьте возможность принимать для команд не имя файла/папки, а путь в формате `"/dir1/dir2/dir3"` или `"/dir1/dir2/file"`. Путь до файла не может заканчиваться на `/`
1. Добавьте возможность принимать для команды `ls` имя папки/путь до папки, который показывает содержимое папки и выводит `"Directory $dir_name/$path_to_dir" doesn't exists`
2. Добавьте возможность удалять файлы и папки при помощи команды `"rm $any_name/$path_to_any"`
## Задание 5 (гробы)
1. Напишите реализацию функции `(izi_way) :: ((((a -> b) -> a) -> a) -> b) -> b`, которая будет компилироваться и при этом реализация этой функции будет иметь схожую сигнатуру при `:t` без явно объявленной сигнатуры
2. Напишите реализацию красивого отображения файловой системы (как в пакете `tree`)
Представим, что `N0 ~ \z s -> z, N1 ~ \z s -> s z, N2 ~ \z s -> s (s z), ... `. Для тестирования заданий рекомендую использовать в качестве `z = 0, s = (+ 1)`
3. Напишите функцию сложения таких чисел
4. Напишите функцию умножения таких чисел
5. Напишите функцию вычитания таких чисел
6. Напишите функцию возведения в степень таких чисел
7. Реализуйте балансировку дерева (и измените тип соответственно) принимая, что это не тернарное дерево, а биномиальная куча
8. Реализуйте балансировку дерева (и измените тип соответственно) принимая, что это не тернарное дерево, а декартово бинарное дерево
9. Реализуйте балансировку дерева (и измените тип соответственно) принимая, что это не тернарное дерево, а фибоначчиева куча
10. Постройте тип `Map k v` используя `Tree` как основу для этого типа
1. Реализуйте функцию `"cp $path_to_dir $path_to_dir/cp $path_to_file $path_to_file"`, который копирует папку и её содержимое/файл и если есть совпадения в папках/файлах то выводит запрос, в котором ожидает символ `"Y"` или `"y"` для замещения, иначе не копирует 
2. Реализуйте функцию `"revoke $k"` который принимает число команд, которые нужно откатить. Если `$k` больше, чем количество команд, то вывести сообщение об ошибке. 
